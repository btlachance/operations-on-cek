;; #lang racket
;; (struct succ (n))
;; (struct -z ())
;; (define z (-z))
;; (define pred succ-n)
;; (define iszero -z?)
;; (define (->num n)
;;   (match n
;;     [(-z) 0]
;;     [(succ n) (add1 (->num n))]))

(let* ([Z (lambda (f) ((lambda (x) (f (lambda (v) ((x x) v))))
                       (lambda (x) (f (lambda (v) ((x x) v))))))]
       [add (Z (lambda (add0) (lambda (m) (lambda (n) (if (iszero m)
                                                          n
                                                          ((add0 (pred m)) (succ n)))))))]
       [mult (Z (lambda (mult0) (lambda (m) (lambda (n) (if (iszero m)
                                                            z
                                                            (if (iszero (pred m))
                                                                n
                                                                ((add n) ((mult0 (pred m)) n))))))))]
       [sub (Z (lambda (sub0) (lambda (m) (lambda (n) (if (iszero n)
                                                          m
                                                          ((sub0 (pred m)) (pred n)))))))]
       [one (succ z)]
       [two ((add one) one)]
       [four ((add two) two)]
       [five ((add four) one)]
       [ten ((mult five) two)]
       [hundred ((mult ten) ten)]
       [thousand ((mult hundred) ten)]
       [fact (Z (lambda (fact0) (lambda (n) (if (iszero n)
                                                one
                                                ((mult n) (fact0 (pred n)))))))])
  (if (iszero ((sub (fact ((add five) two)))
               ((add ((mult thousand) five)) ((mult four) ten))))
      (lambda (success) success)
      (lambda (failure) failure)))
