#lang racket
(require rackunit)
(provide (struct-out language)
         (struct-out binding)
         binding-equal?
         check-binds?
         check-not-binds?
         (struct-out pattern-presult)
         (struct-out form))

;; A language is a (language (listof form))
(struct language (forms))

;; A type is an id with a transformer binding. The value for that
;; binding must be a form

;; A binding is a (binding id type) where the first id is the
;; identifier being bound and the second id represents the
;; identifier's type
(struct binding (id type))
(define (binding-equal? b1 b2)
  (and (free-identifier=? (binding-id b1) (binding-id b2))
       (free-identifier=? (binding-type b1) (binding-type b2))))
(define-binary-check (check-binds? actual expected)
  (define result actual)
  (and (pattern-presult? result)
       (memf (lambda (b) (binding-equal? b expected))
             (pattern-presult-bindings actual))))
(define-binary-check (check-not-binds? actual unexpected)
  (define result actual)
  (or (false? result)
      (not (memf (lambda (b) (binding-equal? b unexpected))
                 (pattern-presult-bindings actual)))))

;; A pattern-presult is one of
;; - #f
;; - (pattern-presult type (listof binding)) representing the result
;;   of succesfully parsing a pattern's syntax
(struct pattern-presult (type bindings))


;; A form is a
(struct form (type ;; type
              parse-pattern ;; (syntax -> pattern-presult)
              parse-template ;; (syntax (listof binding) -> boolean)
              compile-pattern ;; (syntax -> ???)
              compile-template ;; (syntax -> ???)
              is-default?)) ;; (-> boolean)

;; A form represents a piece of syntax that the user specified. It can
;; either be generated by the language or explicitly defined by the
;; user (this way, it acts as a sort of low-level extension
;; interface). The is-default? field must be a function because its
;; answer need all of the language forms' transformer bindings to be
;; setup. Those aren't setup until all forms are created, so we have
;; to delay the answer and make sure we only call that function when
;; all of those are setup.

;; TODO somewhere, before we call compile-pattern/compile-template, we
;; need to produce syntax that is annotated with its type.
;; Typechecking shouldn't have to happen again during compilation, so
;; pattern/template parsing needs to produce syntax where each subform
;; is associated with its type.
