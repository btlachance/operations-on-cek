#lang racket
(require rackunit)
(provide (struct-out language)
         mk-language
         (struct-out binding)
         binding-equal?
         check-binds?
         check-not-binds?
         (struct-out pattern-presult)
         (struct-out template-presult)
         (struct-out form))

;; A language is a (language (listof form)
;;                           (syntax -> pattern presult)
;;                           (syntax (listof binding) -> boolean))
(struct language (forms parse-pattern parse-template))

;; mk-language : (listof form) -> language
(define (mk-language forms)
  (define (parse-pattern stx)
    (for/or ([f forms])
      ((form-parse-pattern f) stx)))

  (define (parse-template stx bindings)
    (define (default? f) ((form-is-default? f))) ;; yes, ((parens))
    (define-values (plain-forms default?-forms)
      (partition (compose not default?) forms))
    (for/or ([f (in-sequences plain-forms default?-forms)])
      ((form-parse-template f) stx bindings)))

  (language forms parse-pattern parse-template))

;; A type is an id with a transformer binding. The value for that
;; binding must be a form

;; A binding is a (binding id type) where the first id is the
;; identifier being bound and the second id represents the
;; identifier's type
(struct binding (id type))
(define (binding-equal? b1 b2)
  (and (free-identifier=? (binding-id b1) (binding-id b2))
       (free-identifier=? (binding-type b1) (binding-type b2))))
(define-binary-check (check-binds? actual expected)
  (define result actual)
  (and (pattern-presult? result)
       (memf (lambda (b) (binding-equal? b expected))
             (pattern-presult-bindings actual))))
(define-binary-check (check-not-binds? actual unexpected)
  (define result actual)
  (or (false? result)
      (not (memf (lambda (b) (binding-equal? b unexpected))
                 (pattern-presult-bindings actual)))))

;; A pattern-presult is one of
;; - #f
;; - (pattern-presult type (listof binding)) representing the type
;;   of a succesfully parsed pattern and the variables it binds
(struct pattern-presult (type bindings))

;; A template-presult is one of
;; - #f
;; - (template-presult type) representing the type of a succesfully
;;   parsed template
(struct template-presult (type))

;; A form is a
(struct form (type ;; type
              parse-pattern ;; (syntax -> pattern-presult)
              parse-template ;; (syntax (listof binding) -> boolean)
              compile-pattern ;; (syntax -> ???)
              compile-template ;; (syntax -> ???)
              is-default?)) ;; (-> boolean)

;; A form represents a piece of syntax that the user specified. It can
;; either be generated by the language or explicitly defined by the
;; user (this way, it acts as a sort of low-level extension
;; interface). The is-default? field must be a function because its
;; answer need all of the language forms' transformer bindings to be
;; setup. Those aren't setup until all forms are created, so we have
;; to delay the answer and make sure we only call that function when
;; all of those are setup.

;; TODO somewhere, before we call compile-pattern/compile-template, we
;; need to produce syntax that is annotated with its type.
;; Typechecking shouldn't have to happen again during compilation, so
;; pattern/template parsing needs to produce syntax where each subform
;; is associated with its type.
